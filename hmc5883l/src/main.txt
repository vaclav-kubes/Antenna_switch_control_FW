
#include <avr/io.h>         // AVR device-specific IO definitions
#include <avr/interrupt.h>  // Interrupts standard C library for AVR-GCC
//#include <twi.h> // I2C library
#include "timer.h"
#include <uart.h>
#include <stdlib.h> 
#include <gpio.h>
#include <i2cmaster.h> 

#ifndef F_CPU
# define F_CPU 16000000  // CPU frequency in Hz required for UART_BAUD_SELECT
#endif

#define HMC588L_I2C_ADR 0x1E
#define CONFIG_REG_A 0


volatile int16_t X = 0;
volatile int16_t Y = 0;
volatile int16_t Z = 0;
volatile uint8_t new_sensor_data = 0;

int main (void){
  char string[2];
  GPIO_mode_output(&DDRB, PB5);
  i2c_init();
  uart_init(UART_BAUD_SELECT(9600, F_CPU));
  sei();  // Needed for UART
  /*
  if (twi_test_address(HMC588L_I2C_ADR) == 0)
        uart_puts("I2C sensor detected\r\n");
    else {
        uart_puts("[ERROR] I2C device not detected\r\n");
        //while (1);
    }*/
  
   if (i2c_start(0b00111100)==0){

    uart_puts("setting sensor\n");
    // Set internal memory location
    if(! i2c_write(CONFIG_REG_A)) uart_puts("a\n");
    
    //twi_stop();
    //twi_start();
    i2c_write(0b01110000);
    i2c_write(0b00100000);
    if(! i2c_write(0b00000000)) uart_puts("setting succesfull");
    uart_puts("neco");
    i2c_stop();
    if(! i2c_start(0b00111101)) uart_puts("succ");
    X = (int)(int16_t)(i2c_readAck() | i2c_readAck() << 8);
    uart_puts("new data: ");
      itoa(X, string, 10);
      uart_puts(string);
      uart_puts(" ");
		Y = (int)(int16_t)(i2c_readAck() | i2c_readAck() << 8);
    itoa(Y, string, 10);
      uart_puts(string);
      uart_puts(" ");
		Z = (int)(int16_t)(i2c_readAck() | i2c_readAck() << 8);
    itoa(Z, string, 10);
      uart_puts(string);
      uart_puts("\n");
  i2c_stop();
   }
   //i2c_stop();
  TIM1_ovf_1sec();
  TIM1_ovf_enable();
  
  while(1){
    if (new_sensor_data){
      uart_puts("new data: ");
      itoa(X, string, 10);
      uart_puts(string);
      uart_puts(" ");

      itoa(Y, string, 10);
      uart_puts(string);
      uart_puts(" ");

      itoa(Z, string, 10);
      uart_puts(string);
      uart_puts("\n");

      new_sensor_data = 0;
      uart_puts("1\n");
    }
  }
  return 0;
}


ISR(TIMER1_OVF_vect)
{
  PORTB = PORTB ^ (1<<PB5);
  //static uint8_t MSB = 0;
  //static uint8_t LSB = 0;
  //char str[2];
      //uart_puts("1sec\n");
/*
      twi_start();
      if (twi_write((HMC588L_I2C_ADR<<1) | TWI_WRITE) == 0) {
          twi_write(3);
          //twi_stop();

          twi_start();
          twi_write((HMC588L_I2C_ADR<<1) | TWI_READ);
          uart_puts("I2Cread: ");
          X = twi_read(TWI_ACK);
          itoa(X, str, 10);
          uart_puts(str);
          X = twi_read(TWI_ACK);
          itoa(X, str, 10);
          uart_puts(str);
          
                    X = twi_read(TWI_ACK);
          itoa(X, str, 10);
          uart_puts(str);
          X = twi_read(TWI_ACK);
          itoa(X, str, 10);
          uart_puts(str);
                    X = twi_read(TWI_ACK);
          itoa(X, str, 10);
          uart_puts(str);
          X = twi_read(TWI_ACK);
          itoa(X, str, 10);
          uart_puts(str);
          X = twi_read(TWI_ACK);
          itoa(X, str, 10);
          uart_puts(str);
          X = twi_read(TWI_ACK);
          itoa(X, str, 10);
          uart_puts(str);
          X = twi_read(TWI_ACK);
          itoa(X, str, 10);
          uart_puts(str);
          X = twi_read(TWI_ACK);
          itoa(X, str, 10);
          uart_puts(str);
          twi_stop();
      }*/
      //new_sensor_data = 1;
      //twi_stop();
      //if(i2c_start(0b00111100)) uart_puts("Q");
      //i2c_start(0b00111100);
      // Read values from Temp/Humid sensor
      //GPIO_write_high(PORTB, 5);
      
      //uart_puts("2\n");
      //twi_start();
      //uart_puts("3\n");
        //uart_puts("4\n");
          //if(i2c_write(3)) uart_puts("b");
          //uart_puts("5\n");
        //i2c_stop();
          //twi_stop();
          // Set internal memory location
          i2c_start(0b00111100);
          i2c_write(3);
          i2c_rep_start(0b00111101);// uart_puts("x");
          //i2c_write(HMC588L_I2C_ADR + I2C_READ);
          //uart_puts("I2Cread: ");
          
          X = (int)(int16_t)(i2c_readAck() | i2c_readAck() << 8);
		      Y = (int)(int16_t)(i2c_readAck() | i2c_readAck() << 8);
		      Z = (int)(int16_t)(i2c_readAck() | i2c_readAck() << 8);

          i2c_stop();

          new_sensor_data = 1;
      
}
