
#include <avr/io.h>         // AVR device-specific IO definitions
#include <avr/interrupt.h>  // Interrupts standard C library for AVR-GCC
#include <twi.h> // I2C library
#include "timer.h"
#include <uart.h>
#include <stdlib.h> 
#include <gpio.h>
//#include <i2cmaster.h> 
#include <util/delay.h>
//#include <math.h>
#include <ftoa.h>
#include <hmc5883l.h>
#ifndef F_CPU
# define F_CPU 16000000  // CPU frequency in Hz required for UART_BAUD_SELECT
#endif

#define HMC588L_I2C_ADR 0x1E
#define CONFIG_REG_A 0

volatile int16_t X = 0;
volatile int16_t Y = 0;
volatile int16_t Z = 0;
volatile uint8_t new_sensor_data = 0;
//int8_t pokus = 0b11111111;

int main (void){
  char string[12];
  GPIO_mode_output(&DDRB, PB5);
  //twi_init();
  uart_init(UART_BAUD_SELECT(9600, F_CPU));
    // Needed for UART

    if (twi_test_address(HMC588L_I2C_ADR) == 0)
        uart_puts("I2C sensor detected\r\n");
    else {
        uart_puts("[ERROR] I2C device not detected\r\n");
    }
    //itoa(pokus, string, 10);
    //uart_puts(string);
    /*
    uart_puts("Self test...\n");
    twi_start();
    twi_write(HMC588L_I2C_ADR<<1 | TWI_WRITE);
    twi_write(0);
    twi_write(0x11);
    twi_write(0b00100000);
    twi_write(0x01);
    twi_start();
    _delay_ms(10);
    twi_write(HMC588L_I2C_ADR<<1 | TWI_READ);
    itoa(twi_read(TWI_ACK) | twi_read(TWI_ACK), string, 10);
    uart_puts(string);
    uart_puts(" ");
    itoa(twi_read(TWI_ACK) | twi_read(TWI_ACK), string, 10);
    uart_puts(string);
    uart_puts(" ");
    itoa(twi_read(TWI_ACK) | twi_read(TWI_NACK), string, 10);
    uart_puts(string);
    uart_puts("\n");
    
    twi_start();
    twi_write(HMC588L_I2C_ADR<<1 | TWI_WRITE);
    twi_write(0);
    twi_write(0x12);
    twi_write(0b00100000);
    twi_write(0x01);
    twi_start();
    _delay_ms(10);
    twi_write(HMC588L_I2C_ADR<<1 | TWI_READ);
    itoa(twi_read(TWI_ACK) | twi_read(TWI_ACK), string, 10);
    uart_puts(string);
    uart_puts(" ");
    itoa(twi_read(TWI_ACK) | twi_read(TWI_ACK), string, 10);
    uart_puts(string);
    uart_puts(" ");
    itoa(twi_read(TWI_ACK) | twi_read(TWI_NACK), string, 10);
    uart_puts(string);
    uart_puts("\n");
    twi_stop();

    twi_start();//start positive bias measuring
    twi_write(HMC588L_I2C_ADR<<1 | TWI_WRITE);
    twi_write(0);
    twi_write(0b01110001);
    twi_write(0b11100000);
    twi_write(0b00000000);
    _delay_ms(10);
    uart_puts("Positive bias:");
    twi_write(HMC588L_I2C_ADR<<1 | TWI_READ);
    itoa(twi_read(TWI_ACK) | twi_read(TWI_ACK), string, 10);
    uart_puts(string);
    uart_puts(" ");
    itoa(twi_read(TWI_ACK) | twi_read(TWI_ACK), string, 10);
    uart_puts(string);
    uart_puts(" ");
    itoa(twi_read(TWI_ACK) | twi_read(TWI_NACK), string, 10);
    uart_puts(string);
    uart_puts("\n");

  twi_start();
   if (twi_write(HMC588L_I2C_ADR<<1 | TWI_WRITE)==0){
        uart_puts("setting sensor\n");
        if(! twi_write(0)) uart_puts("start config\n");
        twi_write(0b01110100);
        twi_write(0b00100000);
        if(! twi_write(0b00000000)) uart_puts("setting succesfull\n");
        //twi_stop();
        /*
        twi_start();
        twi_write(0b00111100);
        twi_write(0);
        twi_stop();*/
        /*
        twi_start();
        if(! twi_write(0b00111101)) uart_puts("reading\n");
        //twi_write(0);

        itoa(twi_read(TWI_ACK), string, 2);
        uart_puts(string);
        uart_puts(" ");

        itoa(twi_read(TWI_ACK), string, 2);
        uart_puts(string);
        uart_puts(" ");

        itoa(twi_read(TWI_NACK), string, 2);
        uart_puts(string);
        uart_puts("\n");
        twi_stop();
        //twi_start();
        //twi_write(0b00111100);
        //twi_write(0x03);
   }*/
  HMC588L_init();
  sei();
  TIM1_ovf_262ms();
  TIM1_ovf_enable();
  
  while(1){
    if (new_sensor_data){
      //uart_puts("new data: ");
      itoa(X, string, 10);
      uart_puts(string);
      uart_puts("\t");

      itoa(Y, string, 10);
      uart_puts(string);
      uart_puts("\t");

      itoa(Z, string, 10);
      uart_puts(string);
      uart_puts("\t→→\t");

      double heading = 180*atan2((double)(Y + 182)/1.090f, (double)(X - 10)/1.090f)/M_PI;

      heading += (5.0 + (35.0 / 60.0));

      if (heading < 0.0)
      {
        heading += 360.0;
      }

      if (heading > 360.0)
      {
        heading -= 360.0;
      }
      //heading *= (180/M_PI);
      int16_t n = (int16_t) heading;
      uint16_t m = (uint16_t)((heading-(float)n) * 100);
      itoa(n, string, 10);
      uart_puts(string);
      uart_puts(".");
      itoa(m, string, 10);
      uart_puts(string);
      uart_puts("°");
      uart_puts("\t→→\t");

      ftoa(heading, string, 2);
      uart_puts(string);
      uart_puts("\n");
      //float heading = atan2(Y, X);
      //sprintf(string, "%f", heading);
      //ftoa(heading, string, 3);
      //uart_puts(string);
      //uart_puts("\n");

      new_sensor_data = 0;
      //uart_puts("1\n");
    }
  }
  return 0;
}


ISR(TIMER1_OVF_vect)
{
    //PORTB = PORTB ^ (1<<PB5);
    /*if (twi_test_address(HMC588L_I2C_ADR) == 0)
        uart_puts("I2C sensor detected\r\n");
    else {
        uart_puts("[ERROR] I2C device not detected\r\n");
        //while (1);
    }*/
    twi_start();
    if(twi_write(HMC588L_I2C_ADR<<1 | TWI_WRITE) == 0) PORTB = PORTB ^ (1<<PB5);
    twi_write(3);
    //twi_stop();

    //twi_stop();
    twi_start();
    //if(! twi_write(0b00111101)) PORTB = PORTB ^ (1<<PB5);
    twi_write(0b00111101);
    X = (twi_read(TWI_ACK)<<8 | twi_read(TWI_ACK));
    Z = (twi_read(TWI_ACK)<<8 | twi_read(TWI_ACK));
    Y = (twi_read(TWI_ACK)<<8 | twi_read(TWI_NACK));

    twi_stop();

    new_sensor_data = 1;
      
}
