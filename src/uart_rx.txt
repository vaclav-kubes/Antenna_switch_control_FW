#include <avr/io.h>         // AVR device-specific IO definitions
#include <avr/interrupt.h>  // Interrupts standard C library for AVR-GCC
#include <twi.h> // I2C library
#include "timer.h"
#include "timer_my.h"
#include <uart.h>
#include <stdlib.h> 
#include <util/delay.h>
#include <gpio.h>
//#include <math.h>
#include <string.h>
#include <adc.h>
#include <hmc5883l.h>
#include <mcp9808.h>
#include <ftoa_my.h>
#include "antenna_switch_IO.h"

#ifndef F_CPU
# define F_CPU 16000000UL  // CPU frequency in Hz required for UART_BAUD_SELECT
#endif

void ANT_init(){
    GPIO_mode_output(&DDRD, ANT01);
    GPIO_write_low(&PORTD, ANT01);
    GPIO_mode_output(&DDRD, ANT02);
    GPIO_write_high(&PORTD, ANT02);
    GPIO_mode_output(&DDRD, ANT03);
    GPIO_write_high(&PORTD, ANT03);
    GPIO_mode_output(&DDRD, ANT04);
    GPIO_write_high(&PORTD, ANT04);
    GPIO_mode_output(&DDRD, ANT05);
    GPIO_write_high(&PORTD, ANT05);

    GPIO_mode_output(&DDRC, ANT11);
    GPIO_write_high(&PORTC, ANT11);
    GPIO_mode_output(&DDRC, ANT12);
    GPIO_write_high(&PORTC, ANT12);
    GPIO_mode_output(&DDRD, ANT13);
    GPIO_write_high(&PORTD, ANT13);
    GPIO_mode_output(&DDRB, ANT14);
    GPIO_write_high(&PORTB, ANT14);
    GPIO_mode_output(&DDRB, ANT15);
    GPIO_write_high(&PORTB, ANT15);
}

int main(void){
    //ANT_init();
    GPIO_mode_output(&DDRC, LED);
    //twi_init();
    uart_init(UART_BAUD_SELECT(9600, F_CPU));
    //ADC_init();
    sei();

   // uart_puts("START\r\n");
    GPIO_write_low(&PORTC, LED);
    
    while(1){
        uint16_t c = uart_getc();
        //unsigned char dummy;
        //while ( UCSR0A & (1<<RXC0) ) dummy = UDR0;
        char str[9];
        char cc;
        //_delay_ms(60);
        /*UCSR0B = UCSR0B & ~(0b10010000);
        _delay_ms(50);
        itoa(c, str, 2);
        uart_puts(str);
        uart_puts("→\t");
        UCSR0B = UCSR0B | (1 << RXEN0) |(1<<RXCIE0);*/

        if(c != UART_NO_DATA) {
            /*itoa(UCSR0B, str, 2);
            uart_puts(str);
            uart_puts("\t→\t");
            UCSR0B = UCSR0B & ~(0b00010000);*/
            UCSR0B = UCSR0B & ~(0b10010000);
            //_delay_ms(50);
            GPIO_toggle(&PORTC, LED);
            cc = c & 0x00ff;
            itoa(cc, str, 2);
            uart_puts(str);
            uart_puts("  ");
            itoa(c & 0xff00, str, 2);
            uart_puts(str);
            //uart_puts_p(UCSR0B);
            uart_puts("\r\n");
            _delay_ms(20);
            UCSR0B = UCSR0B | (1 << RXEN0) |(1<<RXCIE0);
        }
        //_delay_ms(10);
        /*uart_puts("AHOJ\r\n");
        GPIO_write_high(&PORTC, LED);
        _delay_ms(250);
        GPIO_write_low(&PORTC, LED);
        /*uint16_t c = uart_getc();
        if(c == UART_BUFFER_OVERFLOW){
            GPIO_write_low(&PORTD, ANT02);
        }else if(c == UART_OVERRUN_ERROR){
            GPIO_write_low(&PORTD, ANT03);
        }else if(c == UART_NO_DATA){
            GPIO_write_low(&PORTD, ANT04);
        }else if(c == UART_FRAME_ERROR){
            GPIO_write_low(&PORTD, ANT05);
        }else if(c == UART_PARITY_ERROR){
            GPIO_write_low(&PORTD, ANT01);
        }else{
                GPIO_write_low(&PORTD, ANT01);
                GPIO_write_low(&PORTD, ANT02);
                GPIO_write_low(&PORTD, ANT03);
                GPIO_write_low(&PORTD, ANT04);
                GPIO_write_low(&PORTD, ANT05);
            }*/
        //_delay_ms(250);
        /*char str [16];
       
        char c = 0x00FF & uart_getc();
        GPIO_write_high(&PORTC, LED);
        str[0] = c;
        uint8_t i = 0;
        while(c != UART_NO_DATA){
            i++;
            str[i] = c;
            c = uart_getc();
        }
        uart_puts(str);*/
        
    }

}